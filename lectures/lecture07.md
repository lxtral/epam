# Bash And Regular Expressions

## Shebang
 
`#!/bin/bash`  
`#!/usr/bin/env bash`  
`#!/bin/python`  
 
## Variables
 
Все переменные в баше - строка  
 
`VAR="Hello"` - объявление  
`$VAR` - вызов  
`${VAR}` - для отделения переменной от  
`${VAR:="Hello"}` - значение по умолчанию (если переменная ранее не объявлена)  
`ARR=(1 2 3 4 5)` - массив  
`${ARR[@]}` или  `${ARR[*]}` - вызов  
`$1 $2 $@ $*` - зарезервированные переменные для аргументов  
`$#` - количество аргументов на входе  
`$$` - выводит pid текущего процесса  
`$?` - exit код предыдущего процесса  
 
`env` - посмотреть все переменные в системе  
 
`declare -i A=123` - объявление переменное типа int   
 
## Math
 
`A=1+1`  
`A=$((1+1))`  
`B=5`  
`C=$((A+B))`  
`bc` - консольный калькулятор   
 
## if and case
 
`&&` и `||` - и/или
`[[ 0 -ne 1 ]]` - сравнение (0 не равен 1)
`-lt` - меньше  
`-le` - меньше или равно  
`-ge` - больше или равно  
`-gt` - больше  
`-eq` - равно  
`if [[ ]]; then; else; elseif [[ ]]; then; fi`  
 
```
case $VAR in  
    value1) command1 ;;  
    value2) command2 ;;  
    *) command3 ;;  
esac  
```
 
## Subshell And Command Execution
 
`$( list )` - command execution вызывает команду и вставляет её вывод  
`( list; )` - subshell создает подпроцесс для выполнения команды  
`{ list; }` - subshell для выполнения нескольких команд внутри скобок  
 
## Loops
 
`for i in 1 2 3 4; do echo $i; done`  
`while sleep 10; do date; done`  
`untill`  
 
`for i in $(seq 10); do echo $i; done` - проитерировать от 1 до 10  
`for i in $(seq -10 10); do echo $i; done` - проитерировать от -10 до 10  
`for i in $(seq 10 2 100); do echo $i; done` - проитерировать от 10 до 100 с шагом 2  
 
`continue`  
 
`a=1; while [[ $a -ne 10 ]]; do echo $a; a=$((a+1)); done`  
 
 
## Functions And Aliases
 
`alias grep='grep -color'` - сократить команду grep -color до grep  
`cd(){ command cd $@; ls; }` - функция  
`local` - делает переменную в функции локальной  
`unset` - убирает функцию или переменную  
`:(){ :|:& };:` - форк (никогда не запускать!)  
 
`files=("$@")` - записать все аргументы в массив files  
`shift` - сдвинуть все элементы массива на один влево  
`exit` - выход из функции  
`return` - возвращает текущее значение и завершает функцию  
 
## Regular Expressions
 
https://regex101.com  
 
`^` - начало строки  
`$` - конец строки  
`.` - любой символ  
`.*` - любое количество любых символов  
`.?` - либо есть символ, либо нет  
`.+` - как минимум один символ должен быть  
`[ ]` - интервал символов  
`[^ ]` - кроме этого интервала  
`{1}` - количество символов, которое нам нужно  
`{2,3}` - от двух до трёх символов  
`{3,}` - более трёх символов  
`(.*)` - группы символов  
 
`echo bash.sh | sed -r  's/([^\.]*)\.(.*)/\1.\2/'` - выведем всё, что нашли  
`echo bash.sh | sed -r 's/([^\.]*)\.(.*)/\2.\1/'` - поменяем местами группы  
 
`\n` - символ конца строки и перевод на новую  
`\r` -  
`\s` -  
`\w` - слово, без учета символов  
`\b` -  
`\d` - цифры  
`\D` - всё, кроме цифр  
 
`ls | sed 's/.*\.sh/.test/g'`  
 
`sed -r` - для нормального использования регулярных выражений в sed  
 
`(?=) (?<=)`  - lookahead/lookbehind  
`(?!=) (?<!)` - negative lookahead/lookbehind  
 
## Bash Features
 
Variable substitution `( ${VAR} )`  
History substitution `( !! !$ !2 ^foo^bar )`  
Process substitution `( <(ls) >(cat) )`  
